<style>
  :root {
    --bg: #f7f7f7;
    --text: #222;
    --primary: #4CAF50;
    --button-bg: #444;
    --button-hover: #666;
    --border: #ccc;
  }

  body {
    margin: 5%;
    padding-top: 2%;
    font-family: Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  h1 {
    font-size: 2.5rem;
    margin-bottom: 1rem;
    text-align: center;
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    width: 100%;
    max-width: 800px;
  }

  .button-group {
    display: flex;
    gap: 1rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  button {
    background: var(--button-bg);
    color: white;
    border: none;
    padding: 0.8rem 1.4rem;
    font-size: 1.2rem;
    border-radius: 8px;
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
  }

  button:hover {
    background: var(--button-hover);
  }

  button:focus {
    outline: 3px solid var(--primary);
  }

  button:active {
    transform: scale(0.97);
  }

  fieldset {
    border: 1px solid var(--border);
    padding: 1rem;
    border-radius: 8px;
  }

  legend {
    padding: 0 0.5rem;
    font-weight: bold;
  }

  label {
    display: block;
    margin-bottom: 0.5rem;
  }

  #gen_slider {
    width: 100%;
    margin-top: 0.5rem;
    height: 22px;
    appearance: none;
    background: #d3d3d3;
    border-radius: 5px;
    outline: none;
    transition: 0.2s;
  }

  #gen_slider:hover {
    background: #b3b3b3;
  }

  #gen_slider:focus {
    box-shadow: 0 0 8px var(--primary);
  }

  #gen_slider::-webkit-slider-thumb {
    appearance: none;
    width: 20px;
    height: 20px;
    background: var(--primary);
    border-radius: 50%;
    cursor: pointer;
  }

  canvas {
    border: 1px solid var(--border);
    width: 100%;
    max-width: 800px;
    height: 55vh;
    margin-top: 2rem;
  }

  a {
    color: var(--primary);
    text-decoration: none;
    font-weight: bold;
    display: block;
    margin-top: 1.5rem;
    text-align: center;
  }

  a:hover {
    text-decoration: underline;
  }
</style>

<body>

  <h1>Conway's Game of Life</h1>

  <div class="controls">

    <div class="button-group">

      <button onclick="restartGOL()" aria-label="Regenerate grid">
        üîÑ <span>Re-generate</span>
      </button>

      <button onclick="restartGOL(true)" aria-label="Clear grid">
        üßπ <span>Clear</span>
      </button>

      <button onclick="pauseGOL()" id="pause" aria-label="Pause simulation">
        ‚è∏Ô∏è <span>Pause</span>
      </button>

          <label>
      <input type="checkbox" id="life-display" >
      Show Life Display
    </label>

    </div>

    <fieldset>
      <legend>Generation Speed</legend>

      <label for="gen_slider">Generation Time:</label>
      <input 
        type="range"
        min="1"
        max="5000"
        value="500"
        id="gen_slider"
        name="gen_slider"
        aria-describedby="gen_time_label"
      >
      <span id="gen_time_label"></span>
    </fieldset>

    <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_blank">
      Learn more about Conway's Game of Life ‚Üí
    </a>

  </div>

    <canvas
      class="slide"
      id="b"
      style="display: block"
      tabindex="0"
      aria-label="conway's game of life"
    >
    </canvas>

    <script>


      class entity {
        constructor(x, y, alive) {
          this.x = x;
          this.y = y;
          this.alive = alive;
          this.futureStatus;
        }
      }



      function getRandomInt(max) {
        return Math.floor(Math.random() * max);
      }
      function isColliding(player, other) {
        let { x: x1, w: w1, y: y1, h: h1 } = player;
        let { x: x2, w: w2, y: y2, h: h2 } = other;

        // Check x and y for overlap
        if (x2 > w1 + x1 || x1 > w2 + x2 || y2 > h1 + y1 || y1 > h2 + y2) {
          return false;
        }

        return true;
      }

      //timer rect offset
      let tro = 5;

      let canvasB = document.getElementById("b");
      let ctxB = canvasB.getContext("2d");
      let gridSize = 12;
      let gen = 0;
      let entities = [];
      let life_display = document.getElementById("life-display")
      var drawText = false;



      life_display.addEventListener("change", (event) => {
        console.log(event);
        drawText = event.target.checked;
        ExecuteGameOfLifeSolution(true)
        // Update the game state or re-render if necessary
      });

      for (var i = 0; i < gridSize; i++) {
        for (var j = 0; j < gridSize; j++) {
          //getRandomInt(3)==2
          entities.push(
            new entity(i * gridSize, j * gridSize, getRandomInt(3) == 2)
          );
        }
      }

      function renderSelected() {
        for (let i = 0; i < selected.length; i++) {
          ctxB.fillStyle = "yellow";
          ctxB.fillRect(
            selected[i].x,
            selected[i].y + tro,
            gridSize - 4,
            gridSize - 4
          );
        }
      }
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      canvasB?.addEventListener("mousedown", touchedCell);

      canvasB?.addEventListener("mouseup", touchedCell2);

      let selected = [];
      let selected_lifeForm = [[]];
   

      function touchedCell(event) {
        const rect = canvasB.getBoundingClientRect();
        const scaleX = canvasB.width / rect.width;
        const scaleY = canvasB.height / rect.height;
        mouseX = (event.clientX - rect.left) * scaleX;
        mouseY = (event.clientY - rect.top) * scaleY;

        renderSelected();
        for (var i = 0; i < entities.length; i++) {
          let cur = entities[i];
          let x = cur.x;
          let y = cur.y;

          if (
            isColliding(
              { x: mouseX, y: mouseY, w: 1, h: 1 },
              { x, y, w: gridSize, h: gridSize }
            ) === true
          ) {
            cur.alive = !cur.alive;
            cur.futureStatus = !cur.futureStatus;
            if (selected.includes(cur)) {
              //console.log("remove", selected.indexOf(cur))
              selected.splice(selected.indexOf(cur), 1);
            } else {
              selected.push(cur);
            }
          }
        }
        renderSelected();
      }

      function touchedCell2(event) {
        const rect = canvasB.getBoundingClientRect();
        const scaleX = canvasB.width / rect.width;
        const scaleY = canvasB.height / rect.height;
        let mouse2X = (event.clientX - rect.left) * scaleX;
        let mouse2Y = (event.clientY - rect.top) * scaleY;
        // read from global var mouseX and mouseY and
        //draw a rectangle with some opasity
        //then use the isColliding function to see if the size would overlap
      }

      function restartGOL(clear=false) {
        ctxB.clearRect(0, 0, canvasB.width, canvasB.height);
        selected = [];
        gridSize = 12;
        gen = 0;
        entities = [];
        for (var i = 0; i < gridSize; i++) {
          for (var j = 0; j < gridSize; j++) {
  
              entities.push(
              new entity(i * gridSize, j * gridSize, (clear ? 0 : getRandomInt(3) == 2)))  
          }
        }

        ExecuteGameOfLifeSolution(true)
      }


      let genTime = 500;
      let paused = false;

      let gen_Slider = document.getElementById("gen_slider")
      gen_Slider.value = genTime
      gen_Slider.max = 5000 
      gen_Slider.min=0;
      let gen_time_label = document.getElementById("gen_time_label")
      gen_time_label.innerHTML = gen_Slider.value
    

      function pauseGOL() {
        paused = !paused;
        let pauseButton = document.getElementById("pause");
        pauseButton.innerHTML = paused ? '<span class="icon">‚ñ∂Ô∏è</span>Play' : '<span class="icon">‚è∏Ô∏è</span>Pause';
      } 

      // in other words ExecuteGameOfLifeSolution
      async function ExecuteGameOfLifeSolution(oneShot=false) {
        if (paused && !oneShot) {
          return;
        }

        ctxB.clearRect(0, 0, canvasB.width, canvasB.height);

        for (var i = 0; i < entities.length; i++) {
          let n = 0;
          let { x, y } = entities[i];

          for (var j = 0; j < entities.length; j++) {
            let ox = entities[j].x;
            let oy = entities[j].y;

            // Skip non-alive entities and the cell itself
            if (!entities[j].alive || (x == ox && y == oy)) {
              continue;
            }
            if (
              (x + gridSize === ox && y + gridSize === oy) ||
              (x - gridSize === ox && y - gridSize === oy) ||
              (x === ox && y - gridSize === oy) ||
              (x === ox && y + gridSize === oy) ||
              (x === ox && y + gridSize === oy)
            ) {
              n += 1;
            }
            // Rule 6: Left neighbor
            if (x - gridSize === ox && y === oy) {
              n += 1;
            }

            // Rule 7: Right neighbor
            if (x + gridSize === ox && y === oy) {
              n += 1;
            }

            // Rule 8: Upper-right neighbor
            if (x + gridSize === ox && y - gridSize === oy) {
              n += 1;
            }

            // Rule 9: Lower-left neighbor
            if (x - gridSize === ox && y + gridSize === oy) {
              n += 1;
            }
         
          }

          // too much food kills as well as too few 
          if (
            (entities[i].alive && (n === 2 || n === 3)) ||
            (!entities[i].alive && n === 3)
          ) {
            entities[i].futureStatus = true; // Cell lives in the next generation
          } else {
            entities[i].futureStatus = false; // Cell dies in the next generation
          }

                  // Draw cells
        // Assign the fillStyle based on the value of n
        ctxB.fillStyle = (function() {
          if (n >= 4) {
            return "#00d30b"; // Bright green
          } else if (n == 3) {
            return "#14a02e"; // Medium green
          } else if (n ==2) {
            return "grey"; // Dark green
          } else {
            return "grey"; // Default grey
          }
        })();

        // Draw the rectangle
        ctxB.fillRect(x, y + tro, gridSize - 1, gridSize - 1);

          if(drawText){

            
            ctxB.font = "10px Arial";
            ctxB.fillStyle = "white";
            ctxB.fillText(n, x+2, y + 10 + tro);
          }

        }

        // Update entities based on futureStatus
        for (var i = 0; i < entities.length; i++) {
          entities[i].alive = entities[i].futureStatus;
          entities[i].futureStatus = false; // Reset futureStatus
        }

        gen += 1
        document.getElementById("gen_number_label").innerHTML =gen
 let population = entities.filter(e => e.alive);
document.getElementById("pop_number_label").textContent = population.length;


        selected = [];
      }
      ExecuteGameOfLifeSolution();
      var interval = setInterval(ExecuteGameOfLifeSolution, genTime);

      gen_Slider.oninput = function() {
        clearInterval(interval)
        genTime = this.value;
        gen_time_label.innerHTML =this.value
    
        interval = setInterval(ExecuteGameOfLifeSolution, genTime);
      }


  

    </script>

    <div>
      <p> Generations <span id="gen_number_label"> </span> </p>
     <p> Pop <span id="pop_number_label"> </span> </p>

    </div>
  </body>
</html>
